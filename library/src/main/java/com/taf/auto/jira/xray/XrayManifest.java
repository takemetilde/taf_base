package com.taf.auto.jira.xray;

import com.taf.auto.IOUtil;
import com.taf.auto.io.JSONUtil;
import com.taf.auto.jira.IssueTypes;
import com.taf.auto.jira.pojo.AbstractIssue;
import com.taf.auto.jira.pojo.FixVersion;
import com.taf.auto.jira.pojo.xray.XrayFields;
import com.taf.auto.jira.pojo.xray.XrayTest;
import com.taf.auto.jira.pojo.xray.XrayTestPlan;
import com.taf.auto.jira.pojo.xray.XrayTestSet;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

import static com.taf.auto.IOUtil.mkdirs;
import static com.taf.auto.common.PrettyPrinter.prettyArray;
import static com.taf.auto.io.JSONUtil.decode;
import static com.taf.auto.io.JSONUtil.encode;

/**
 * POJO that contains various properties of interest to xray-push-maven-plugin so it can add additional information
 * about the Test Execution it creates. This POJO is populated by xray-fetch-maven-plugin.
 *
 * @author AF04261
 */
public final class XrayManifest {
    private static final Logger LOG = LoggerFactory.getLogger(XrayManifest.class);

    /**
     * Defines a path to a directory for storing transient files generated by xray-fetch.
     * Calls {@link IOUtil#mkdirs(Path)} to ensure the path exists.
     *
     * @return the path to a directory to store xray transient files
     */
    public static Path defineXrayPath() {
        return mkdirs(Paths.get("xray"));
    }

    public static Path defineXraySubpath(String subpath) {
        return mkdirs(defineXrayPath().resolve(subpath));
    }

    private static Path mkdirs(Path path) {
        try {
            IOUtil.mkdirs(path);
        } catch (IOException e) {
            LOG.error("Failed to mkdirs for: " + path, e);
        }
        return path;
    }

    private static Path defineXrayTestPath() {
        return defineXraySubpath("tests");
    }

    /** JIRA Issue Key */
    @JsonProperty
    public String key;

    /** Type of the Issue */
    @JsonProperty
    public IssueTypes type;

    /** Summary of the Issue */
    @JsonProperty
    public String summary;

    /** Fix Version name of the Issue */
    @JsonProperty
    public String fixVersionName;

    @JsonProperty
    public String[] labels;

    @JsonProperty
    public Integer itTeamID;

    @JsonProperty
    public String sprint;

    /** Any fetched Test with Status == Test Ready will be emitted and its key is recorded here for xray-push. */
    @JsonProperty
    public List<String> testReady;

    /** Any fetched Test that are missing test data won't be emitted and its key is recorded here for xray-push. */
    @JsonProperty
    public List<String> pendingTestData;

    /** Any fetched Test with Status != Test Ready won't be emitted and its key is recorded here for xray-push. */
    @JsonProperty
    public List<String> notTestReady;

    /**
     * Any fetched Test that is malformed in JIRA won't be emitted and kits key is recorded here for xray-push. Each
     * key in the map is a Test's JIRA Issue key and the value is the associated error message.
     */
    @JsonProperty
    public Map<String, String> malformed;

    public XrayManifest() {
        testReady = new ArrayList<>();
        pendingTestData = new ArrayList<>();
        notTestReady = new ArrayList<>();
        malformed = new LinkedHashMap<>();
    }

    public boolean peekEmpty() {
        return testReady.isEmpty() && pendingTestData.isEmpty() && notTestReady.isEmpty() && malformed.isEmpty();
    }

    private static Path definePersistencePath() {
        return defineXrayPath().resolve("xray-manifest.json");
    }

    /**
     * Reads the POJO, if it exists. If the persistence file is missing or the decode fails
     * then {@link Optional#empty()} is returned.
     *
     * @return an option for the manifest or empty
     */
    public static Optional<XrayManifest> read() {
        Path path = definePersistencePath();
        if(!Files.exists(path)) {
            LOG.info("Manifest file is missing: " + path);
            return Optional.empty();
        }
        try {
            return Optional.of(decode(Files.readAllBytes(path), XrayManifest.class));
        } catch (IOException e) {
            LOG.error("Failed to decode from: " + path, e);
            return Optional.empty();
        }
    }

    /**
     * Writes the POJO.
     */
    public void write() {
        Path path = definePersistencePath();
        try {
            encode(path, this);
        } catch (IOException e) {
            LOG.error("Failed to encode to: " + path, e);
        }
    }

    /**
     * Examines the given issue and extracts all pertinent bits. The issue must be a
     * {@link XrayTest}, {@link XrayTestSet}, or {@link XrayTestPlan}. Any other type of issue
     * will result in a {@link UnsupportedOperationException}.
     *
     * @param issue the issue to glean fromj
     */
    public void gleanFrom(AbstractIssue issue) {
        key = issue.key;

        Class<? extends AbstractIssue> clazz = issue.getClass();
        if(XrayTest.class.equals(clazz)) {
            type = IssueTypes.Test;
        } else if(XrayTestSet.class.equals(clazz)) {
            type = IssueTypes.Test_Set;
        } else if(XrayTestPlan.class.equals(clazz)) {
            type = IssueTypes.Test_Plan;
        } else {
            throw new UnsupportedOperationException("Unsupported type: " + clazz);
        }

        summary = issue.fields.summary;

        applyFixVersion(issue.fields.fixVersions);

        labels = issue.fields.labels;

        XrayFields fields = (XrayFields) issue.fields;
        if(null != fields.sprints && fields.sprints.length > 0) {
            sprint = fields.sprints[0];
        }
        if(null != fields.IT_Team && fields.IT_Team.length > 0) {
            int id = Integer.valueOf(fields.IT_Team[0].id);
            if(id != 0) {
                itTeamID = id;
            }
        }
        LOG.info(format("Gleaned key=%s; type=%s; summary=%s; fixVersion=%s; labels=%s; sprint=%s; itTeamID=%d",
                key, type, summary, fixVersionName, prettyArray(labels), sprint, itTeamID));
    }

    /**
     * Assigns {@link #fixVersionName} to the result of {@link #extractFixVersionName(FixVersion[])}.
     *
     * @param versions the possible fix versions
     */
    public void applyFixVersion(FixVersion[] versions) {
        extractFixVersionName(versions).ifPresent(fv -> fixVersionName = fv);
    }

    public static Optional<String> extractFixVersionName(FixVersion[] versions) {
        if(null == versions || versions.length < 1) {
            return Optional.empty();
        }
        return Optional.of(versions[0].name);
    }

    /**
     * Used to locally capture the source Issue, be it a Test, Test Set, or Test Plan.
     *
     * @param issue the Issue to encode
     */
    public static void writeSource(AbstractIssue<?> issue) {
        writeIssue(issue, defineXrayPath());
    }

    /**
     * Locally captures an Xray Test that is part of a test run.
     *
     * @param issue the Test to encode
     */
    public static void writeTest(AbstractIssue<?> issue) {
        writeIssue(issue, defineXrayTestPath());
    }

    private static void writeIssue(AbstractIssue<?> issue, Path parentFolder) {
        Path path = parentFolder.resolve(issue.key + ".json");
        LOG.info("Writing source to: " + path);
        try {
            mkdirs(path.getParent());
            Files.write(path, JSONUtil.prettyPrint(issue).getBytes());
        } catch (IOException e) {
            LOG.error("Failed to write: " + path, e);
        }
    }

    /**
     * Used by xray-push to decode a Test placed locally by xray-fetch via {@link #writeTest(AbstractIssue)}.
     *
     * @param key the Test to load
     * @return an option to the Test or empty if the file wasn't found or failed to decode
     */
    public static Optional<XrayTest> readTest(String key) {
        Path testPath = defineXrayTestPath().resolve(key + ".json");
        if(!Files.exists(testPath)) {
            LOG.error("Locally encoded Test not found for: " + key);
            return Optional.empty();
        }
        try {
            XrayTest test = decode(testPath, XrayTest.class);
            LOG.debug("Decoded: " + key);
            if(!key.equals(test.key)) {
                throw new RuntimeException(format("Encoded key: %s does not match expected key: %s", test.key, key));
            }
            return Optional.of(test);
        } catch (Exception e) {
            LOG.error("Failed to decode Test for: " + key, e);
            return Optional.empty();
        }
    }
}
